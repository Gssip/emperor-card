var __webpack_modules__ = {
  907() {
    eval("{\n/**\n * 沉沦色欲的皇帝 — 同层前端卡入口\n *\n * 核心模块：\n * - StartScreen: 开始屏幕\n * - TimeBar: 时间栏解析渲染\n * - MainTextArea: 正文显示\n * - StatusPanel: 角色状态栏\n * - InputBar: 用户输入发送\n * - VariableSync: MVU 变量读写\n * - ChronicleModal: 编年史/读档\n */\n// ============================================================\n// 环境检测\n// ============================================================\n/** 检测是否在酒馆环境中（jQuery 和 SillyTavern 都存在则为酒馆） */\nconst isInTavern = typeof globalThis.$ === 'function'\n    && typeof globalThis.SillyTavern !== 'undefined';\n/** 独立预览时的 mock 数据 */\nconst MOCK_VARS = {\n    '皇帝': { '觉醒度': 12, '当前幕': '第一幕' },\n    '李克': { '警惕度': 35, '内心想法': '这小皇帝今晚倒是格外安分……不过最近他偶尔会问起朝政，需要多加留意。' },\n    '柳妃': { '母爱残存': 42, '内心想法': '儿啊……你又瘦了。可是今晚李克还要来……我无法拒绝他。' },\n    '林婉茹': { '忠诚动摇': 28, '内心想法': '那春药的配方……如果陛下知道真相，他会恨我吗？' },\n    '苏锦儿': { '可策反度': 15, '内心想法': '几秒钟的玩具罢了。不过李克大人今晚会来\"善后\"吧……身体已经开始期待了。' },\n    '沈清芷': { '复仇决心': 88, '身体抗药': 45, '内心想法': '总有一天，我会亲手割下那个男人的头颅……可是这该死的身体，又在渴望他了。' },\n    '赵嫣': { '暗恋强度': 72, '压抑临界': 78, '内心想法': '陛下今日整理寝具时留下的气味……不、不可以想这些。我是尚宫局的人。' },\n};\nconst CHARACTERS = [\n    {\n        name: '李克', role: '丞相', color: 'rgba(180,80,70,0.75)',\n        stats: [{ label: '警惕度', path: '/李克/警惕度' }],\n        thoughtPath: '/李克/内心想法',\n    },\n    {\n        name: '柳妃', role: '太后', color: 'rgba(190,170,90,0.7)',\n        stats: [{ label: '母爱残存', path: '/柳妃/母爱残存' }],\n        thoughtPath: '/柳妃/内心想法',\n    },\n    {\n        name: '林婉茹', role: '御医', color: 'rgba(100,170,130,0.7)',\n        stats: [{ label: '忠诚动摇', path: '/林婉茹/忠诚动摇' }],\n        thoughtPath: '/林婉茹/内心想法',\n    },\n    {\n        name: '苏锦儿', role: '御女营花魁', color: 'rgba(200,100,110,0.7)',\n        stats: [{ label: '可策反度', path: '/苏锦儿/可策反度' }],\n        thoughtPath: '/苏锦儿/内心想法',\n    },\n    {\n        name: '沈清芷', role: '将门之女', color: 'rgba(90,130,180,0.7)',\n        stats: [\n            { label: '复仇决心', path: '/沈清芷/复仇决心' },\n            { label: '身体抗药', path: '/沈清芷/身体抗药' },\n        ],\n        thoughtPath: '/沈清芷/内心想法',\n    },\n    {\n        name: '赵嫣', role: '尚宫局主事', color: 'rgba(150,110,180,0.7)',\n        stats: [\n            { label: '暗恋强度', path: '/赵嫣/暗恋强度' },\n            { label: '压抑临界', path: '/赵嫣/压抑临界' },\n        ],\n        thoughtPath: '/赵嫣/内心想法',\n    },\n];\n// 幕标识映射\nconst ACT_NAMES = {\n    '第一幕': '第一幕·沉沦',\n    '第二幕': '第二幕·裂痕',\n    '第三幕': '第三幕·暗流',\n    '第四幕': '第四幕·破局',\n};\n// ============================================================\n// 工具函数\n// ============================================================\n/** 从变量路径读取值（兼容酒馆/独立环境） */\nfunction readVar(path) {\n    try {\n        const keys = path.split('/').filter(Boolean);\n        let val;\n        if (isInTavern) {\n            // 酒馆环境：优先从 MVU stat_data 读取\n            try {\n                const mvuData = Mvu.getMvuData({ type: 'chat' });\n                val = mvuData?.stat_data;\n            }\n            catch {\n                val = getAllVariables();\n            }\n        }\n        else {\n            // 独立环境：用 mock 数据\n            val = MOCK_VARS;\n        }\n        for (const k of keys) {\n            val = val?.[k];\n        }\n        return val;\n    }\n    catch {\n        return undefined;\n    }\n}\n/** 解析 LLM 消息中的 ☞时间栏☜ */\nfunction parseTimeBar(text) {\n    const match = text.match(/☞(.+?)☜/);\n    if (!match)\n        return null;\n    const parts = match[1].split('-').map(s => s.trim());\n    return {\n        year: parts[0] || '',\n        date: parts[1] || '',\n        weather: parts[2] || '',\n        time: parts[3] || '',\n        location: parts[4] || '',\n        atmosphere: parts[5] || '',\n    };\n}\n/** 提取正文内容（支持两种模式） */\nfunction parseMainText(text) {\n    // 模式1：标签模式 <maintext>...</maintext>\n    const tagged = text.match(/<maintext>([\\s\\S]*?)<\\/maintext>/);\n    if (tagged)\n        return tagged[1].trim();\n    // 模式2：自动提取 — ☞...☜ 之后到 <UpdateVariable> 之前\n    let content = text;\n    content = content.replace(/☞[\\s\\S]*?☜\\s*/, ''); // 移除时间栏\n    content = content.replace(/<UpdateVariable>[\\s\\S]*$/, ''); // 移除变量更新及之后\n    content = content.replace(/<StatusPlaceHolderImpl\\/?>[\\s]*$/, ''); // 移除占位符\n    content = content.replace(/<sum>[\\s\\S]*?<\\/sum>/g, ''); // 移除小总结\n    return content.trim();\n}\n/** 提取 <sum> 内容 */\nfunction parseSummary(text) {\n    const match = text.match(/<sum>([\\s\\S]*?)<\\/sum>/);\n    return match ? match[1].trim() : '';\n}\n/** 提取 <UpdateVariable> 中的 JSONPatch */\nfunction parseVariableUpdate(text) {\n    const match = text.match(/<JSONPatch>([\\s\\S]*?)<\\/JSONPatch>/);\n    if (!match)\n        return [];\n    try {\n        return JSON.parse(match[1].trim());\n    }\n    catch {\n        return [];\n    }\n}\n// ============================================================\n// 模块：开始屏幕\n// ============================================================\nfunction initStartScreen() {\n    const screen = document.getElementById('start-screen');\n    const container = document.getElementById('game-container');\n    screen.addEventListener('click', () => {\n        screen.classList.add('fade-out');\n        setTimeout(() => {\n            screen.style.display = 'none';\n            container.classList.add('active');\n        }, 800);\n        // 尝试全屏\n        try {\n            document.documentElement.requestFullscreen?.();\n        }\n        catch { }\n    });\n}\n// ============================================================\n// 模块：设置面板\n// ============================================================\nfunction initSettingsPanel() {\n    const btn = document.getElementById('settings-btn');\n    const panel = document.getElementById('settings-panel');\n    btn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        panel.classList.toggle('show');\n    });\n    document.addEventListener('click', () => panel.classList.remove('show'));\n    // 编年史按钮\n    document.getElementById('btn-chronicle')?.addEventListener('click', () => {\n        panel.classList.remove('show');\n        document.getElementById('chronicle-modal')?.classList.add('show');\n    });\n    // 全屏切换\n    document.getElementById('btn-fullscreen')?.addEventListener('click', () => {\n        panel.classList.remove('show');\n        if (document.fullscreenElement) {\n            document.exitFullscreen();\n        }\n        else {\n            document.documentElement.requestFullscreen?.();\n        }\n    });\n    // 关闭编年史\n    document.getElementById('chronicle-close')?.addEventListener('click', () => {\n        document.getElementById('chronicle-modal')?.classList.remove('show');\n    });\n    document.getElementById('chronicle-modal')?.addEventListener('click', (e) => {\n        if (e.target === e.currentTarget) {\n            e.currentTarget.classList.remove('show');\n        }\n    });\n}\n// ============================================================\n// 模块：时间栏渲染\n// ============================================================\nfunction renderTimeBar(timeData) {\n    // 从变量读取幕信息\n    const awakening = readVar('/皇帝/觉醒度') ?? 0;\n    const actNum = readVar('/皇帝/当前幕') ?? '第一幕';\n    const actName = ACT_NAMES[actNum] || actNum;\n    const actTag = document.getElementById('act-tag');\n    const awakeningValue = document.getElementById('awakening-value');\n    const awakeningDots = document.getElementById('awakening-dots');\n    if (actTag)\n        actTag.textContent = actName;\n    if (awakeningValue)\n        awakeningValue.textContent = String(awakening);\n    // 渲染觉醒度进度点（每25%一个亮点，共4个）\n    if (awakeningDots) {\n        const litCount = Math.min(4, Math.floor(awakening / 25));\n        const dots = awakeningDots.querySelectorAll('.dot');\n        dots.forEach((dot, i) => {\n            dot.classList.toggle('on', i < litCount);\n        });\n    }\n    // 从时间栏数据渲染\n    if (timeData) {\n        const timeTag = document.getElementById('time-tag');\n        const weatherTag = document.getElementById('weather-tag');\n        const locationTag = document.getElementById('location-tag');\n        if (timeTag)\n            timeTag.textContent = timeData.time || '未知';\n        if (weatherTag)\n            weatherTag.textContent = timeData.weather || '';\n        if (locationTag)\n            locationTag.textContent = timeData.location || '';\n    }\n}\n// ============================================================\n// 模块：状态栏\n// ============================================================\nlet currentCharIndex = 0;\nfunction initStatusPanel() {\n    // 左右翻页导航\n    const prevBtn = document.getElementById('btn-prev');\n    const nextBtn = document.getElementById('btn-next');\n    prevBtn?.addEventListener('click', () => navigateChar(-1));\n    nextBtn?.addEventListener('click', () => navigateChar(1));\n    // 状态栏切换（桌面端设置菜单 + topbar 按钮）\n    document.getElementById('btn-toggle-sidebar')?.addEventListener('click', () => {\n        const panel = document.getElementById('status-panel');\n        if (panel)\n            panel.style.display = panel.style.display === 'none' ? '' : 'none';\n        document.getElementById('settings-panel')?.classList.remove('show');\n    });\n    // 移动端切换\n    const toggle = document.getElementById('mobile-status-toggle');\n    const panel = document.getElementById('status-panel');\n    const overlay = document.getElementById('mobile-overlay');\n    toggle?.addEventListener('click', () => {\n        panel?.classList.toggle('mobile-open');\n        overlay?.classList.toggle('show');\n    });\n    overlay?.addEventListener('click', () => {\n        panel?.classList.remove('mobile-open');\n        overlay?.classList.remove('show');\n    });\n    // 触摸滑动切换角色\n    let touchStartX = 0;\n    panel?.addEventListener('touchstart', (e) => { touchStartX = e.touches[0].clientX; });\n    panel?.addEventListener('touchend', (e) => {\n        const dx = e.changedTouches[0].clientX - touchStartX;\n        if (Math.abs(dx) > 50)\n            navigateChar(dx < 0 ? 1 : -1);\n    });\n}\n/** 导航到上一个/下一个角色 */\nfunction navigateChar(direction) {\n    currentCharIndex = (currentCharIndex + direction + CHARACTERS.length) % CHARACTERS.length;\n    renderCharStatus();\n}\n/** 生成水渍进度条 HTML */\nfunction renderBar(label, value, color) {\n    const pct = Math.min(100, value);\n    const fullClass = pct >= 100 ? ' full' : '';\n    return `<div class=\"s-bar\">\r\n        <span class=\"s-bar-lb\">${label}</span>\r\n        <div class=\"s-bar-track\">\r\n            <div class=\"s-bar-fill${fullClass}\" style=\"width:${pct}%;--sc:${color}\"></div>\r\n        </div>\r\n        <span class=\"s-bar-val\" style=\"color:${color}\">${value}</span>\r\n    </div>`;\n}\nfunction renderCharStatus() {\n    const container = document.getElementById('char-status');\n    if (!container)\n        return;\n    const charData = CHARACTERS[currentCharIndex];\n    if (!charData) {\n        container.innerHTML = '';\n        return;\n    }\n    // 更新导航信息\n    const nameEl = document.getElementById('char-name');\n    const roleEl = document.getElementById('char-role');\n    const idxEl = document.getElementById('char-idx');\n    if (nameEl)\n        nameEl.textContent = charData.name;\n    if (roleEl)\n        roleEl.textContent = charData.role;\n    if (idxEl)\n        idxEl.textContent = `${currentCharIndex + 1}/${CHARACTERS.length}`;\n    // 印章\n    let html = `<div class=\"s-seal\">${charData.name[0]}</div>`;\n    // 属性条\n    let barsHtml = '';\n    for (const stat of charData.stats) {\n        const value = readVar(stat.path) ?? 0;\n        barsHtml += renderBar(stat.label, value, charData.color);\n    }\n    // 内心独白\n    const thought = readVar(charData.thoughtPath) || '';\n    const thoughtHtml = `<div class=\"s-thought\"><em>内心 </em>${thought ? '「' + thought + '」' : '<span style=\"opacity:.3\">暂无</span>'}</div>`;\n    html += `<div class=\"s-info\">${barsHtml}${thoughtHtml}</div>`;\n    container.innerHTML = html;\n}\n// ============================================================\n// 模块：正文渲染\n// ============================================================\nfunction renderMainText(text) {\n    const container = document.getElementById('story-text');\n    // 将文本按段落分割并渲染\n    const paragraphs = text.split('\\n').filter(p => p.trim());\n    container.innerHTML = paragraphs.map(p => `<p>${p}</p>`).join('');\n    // 滚动到底部\n    const textArea = document.getElementById('text-area');\n    textArea.scrollTop = textArea.scrollHeight;\n}\n// ============================================================\n// 模块：编年史\n// ============================================================\nconst chronicles = [];\nfunction addChronicle(time, content) {\n    chronicles.push({ time, content });\n    renderChronicles();\n}\nfunction renderChronicles() {\n    const list = document.getElementById('chronicle-list');\n    if (chronicles.length === 0) {\n        list.innerHTML = '<div class=\"chronicle-entry\"><div class=\"chronicle-time\">承平三年</div>故事尚未展开……</div>';\n        return;\n    }\n    list.innerHTML = chronicles.map(c => `\r\n    <div class=\"chronicle-entry\">\r\n      <div class=\"chronicle-time\">${c.time}</div>\r\n      ${c.content}\r\n    </div>\r\n  `).join('');\n}\n// ============================================================\n// 模块：输入栏\n// ============================================================\nfunction initInputBar() {\n    const input = document.getElementById('user-input');\n    const sendBtn = document.getElementById('send-btn');\n    const loading = document.getElementById('loading-indicator');\n    // 自动调整高度\n    input.addEventListener('input', () => {\n        input.style.height = 'auto';\n        input.style.height = Math.min(input.scrollHeight, 80) + 'px';\n    });\n    // 发送\n    const doSend = () => {\n        const text = input.value.trim();\n        if (!text)\n            return;\n        input.value = '';\n        input.style.height = 'auto';\n        loading.classList.add('show');\n        // 调用酒馆 API 发送消息\n        try {\n            // 将用户输入写到酒馆输入框并触发发送\n            const tavernInput = document.querySelector('#send_textarea');\n            if (tavernInput) {\n                tavernInput.value = text;\n                tavernInput.dispatchEvent(new Event('input', { bubbles: true }));\n            }\n            const sendButton = document.querySelector('#send_but');\n            if (sendButton) {\n                sendButton.click();\n            }\n        }\n        catch (e) {\n            console.error('发送失败:', e);\n            loading.classList.remove('show');\n        }\n    };\n    sendBtn.addEventListener('click', doSend);\n    input.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            doSend();\n        }\n    });\n}\n// ============================================================\n// 模块：消息解析与监听\n// ============================================================\nlet lastProcessedMessageCount = -1;\nfunction processLatestMessage() {\n    try {\n        // 通过 SillyTavern.chat 读取最新消息\n        const chat = SillyTavern.chat;\n        if (!chat || chat.length === 0)\n            return;\n        if (chat.length === lastProcessedMessageCount)\n            return;\n        lastProcessedMessageCount = chat.length;\n        // 获取最新的 AI 消息\n        const latestMsg = chat[chat.length - 1];\n        if (!latestMsg || latestMsg.is_user)\n            return;\n        const msgText = latestMsg.mes || '';\n        if (!msgText)\n            return;\n        // 隐藏加载指示器\n        document.getElementById('loading-indicator')?.classList.remove('show');\n        // 解析时间栏\n        const timeData = parseTimeBar(msgText);\n        renderTimeBar(timeData);\n        // 解析正文\n        const mainText = parseMainText(msgText);\n        if (mainText) {\n            renderMainText(mainText);\n        }\n        // 解析小总结 → 编年史\n        const summary = parseSummary(msgText);\n        if (summary && timeData) {\n            const timeStr = `${timeData.year} ${timeData.date} ${timeData.time}`;\n            addChronicle(timeStr, summary);\n        }\n        // 变量更新由 MVU 框架自动处理，无需手动解析\n        // 刷新状态栏\n        renderCharStatus();\n    }\n    catch (e) {\n        // 初始化阶段可能无消息，静默忽略\n    }\n}\n// 变量更新由 MVU 框架和酒馆助手脚本自动处理\n// 前端只需从 Mvu.getMvuData() 读取最新状态即可\n// ============================================================\n// 阶段3B：正则自动注入\n// ============================================================\nconst REGEX_PREFIX = '[皇帝卡]';\n/** 创建一条 TavernRegex 对象 */\nfunction createRegex(name, findRegex, replaceStr, source, destination, minDepth) {\n    return {\n        id: crypto.randomUUID?.() ?? Math.random().toString(36).slice(2),\n        script_name: `${REGEX_PREFIX} ${name}`,\n        enabled: true,\n        scope: 'character',\n        find_regex: findRegex,\n        replace_string: replaceStr,\n        trim_strings: '',\n        source: {\n            user_input: false,\n            ai_output: false,\n            slash_command: false,\n            world_info: false,\n            ...source,\n        },\n        destination: {\n            display: false,\n            prompt: false,\n            ...destination,\n        },\n        run_on_edit: true,\n        min_depth: minDepth ?? null,\n        max_depth: null,\n    };\n}\n/** 自动注入/更新角色卡正则 */\nasync function setupRegexScripts() {\n    try {\n        await updateTavernRegexesWith(regexes => {\n            // 移除旧的同名正则\n            const filtered = regexes.filter(r => !r.script_name.startsWith(REGEX_PREFIX));\n            // 添加新正则\n            filtered.push(createRegex('隐藏时间栏', '☞[\\\\s\\\\S]*?☜', '', { ai_output: true }, { display: true }), createRegex('隐藏变量更新', '<UpdateVariable>[\\\\s\\\\S]*?</UpdateVariable>', '', { ai_output: true }, { display: true }), createRegex('变量深度限制', '<UpdateVariable>[\\\\s\\\\S]*?</UpdateVariable>', '', { ai_output: true }, { prompt: true }, 6), createRegex('隐藏占位符', '<StatusPlaceHolderImpl/?>', '', { ai_output: true }, { prompt: true }));\n            return filtered;\n        }, { scope: 'character' });\n    }\n    catch (e) {\n        console.warn('[皇帝卡] 正则注入失败:', e);\n    }\n}\n// ============================================================\n// 初始化\n// ============================================================\nfunction init() {\n    initStartScreen();\n    initSettingsPanel();\n    initStatusPanel();\n    initInputBar();\n    if (isInTavern) {\n        // 阶段3A：隐藏酒馆原生消息楼层（同层界面已替代）\n        const hideStyle = document.createElement('style');\n        hideStyle.textContent = `\r\n            #chat .mes { display: none !important; }\r\n            #chat { background: transparent !important; }\r\n        `;\n        document.head.appendChild(hideStyle);\n        // 阶段3B：自动注入正则脚本\n        setupRegexScripts();\n        // 酒馆环境：检测是否已有消息（非首次打开）\n        try {\n            const chatLen = SillyTavern.chat?.length ?? 0;\n            if (chatLen > 1) {\n                document.getElementById('start-screen').style.display = 'none';\n                document.getElementById('game-container').classList.add('active');\n                processLatestMessage();\n            }\n        }\n        catch { }\n        // 监听新消息（轮询方式）\n        setInterval(processLatestMessage, 1000);\n    }\n    // 初始渲染\n    renderTimeBar();\n    renderCharStatus();\n}\n// 兼容初始化：酒馆中需等待正则注入 HTML 后再初始化，独立浏览器用 DOMContentLoaded\nif (isInTavern) {\n    // 等待正则替换将 HTML 元素注入到页面后再初始化\n    // 正则在消息渲染时触发，可能晚于脚本加载\n    let waitAttempts = 0;\n    const maxAttempts = 60; // 最多等 30 秒（每 500ms 检查一次）\n    const waitForDOM = () => {\n        const startScreen = document.getElementById('start-screen');\n        if (startScreen) {\n            console.log('[皇帝卡] DOM 元素已就绪，开始初始化');\n            init();\n        }\n        else if (waitAttempts < maxAttempts) {\n            waitAttempts++;\n            setTimeout(waitForDOM, 500);\n        }\n        else {\n            console.warn('[皇帝卡] 等待 DOM 元素超时（30秒），HTML 可能未通过正则注入');\n        }\n    };\n    $(() => waitForDOM());\n    $(window).on('pagehide', () => { });\n}\nelse {\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', init);\n    }\n    else {\n        init();\n    }\n}\n//# sourceURL=[module]\n
  }
};

var __webpack_exports__ = {};

__webpack_modules__[907]();